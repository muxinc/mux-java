/*
 * Mux API
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * The version of the OpenAPI document: v1
 * Contact: devex@mux.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mux.sdk;

import com.mux.ApiCallback;
import com.mux.ApiClient;
import com.mux.ApiException;
import com.mux.ApiResponse;
import com.mux.Configuration;
import com.mux.Pair;
import com.mux.ProgressRequestBody;
import com.mux.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.mux.sdk.models.CreateTranscriptionVocabularyRequest;
import com.mux.sdk.models.ListTranscriptionVocabulariesResponse;
import com.mux.sdk.models.TranscriptionVocabularyResponse;
import com.mux.sdk.models.UpdateTranscriptionVocabularyRequest;
// TODO: due to import parsing issues for the RDR type; fix in spec in future
import com.mux.sdk.models.ReferrerDomainRestriction;

import java.lang.reflect.Type;

public class TranscriptionVocabulariesApi {
    private ApiClient localVarApiClient;

    public TranscriptionVocabulariesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TranscriptionVocabulariesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    private okhttp3.Call createTranscriptionVocabularyCall(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = createTranscriptionVocabularyRequest;

        // create path and map variables
        String localVarPath = "/video/v1/transcription-vocabularies";

        java.util.List<Pair> localVarQueryParams = new java.util.ArrayList<Pair>();
        java.util.List<Pair> localVarCollectionQueryParams = new java.util.ArrayList<Pair>();
        java.util.Map<String, String> localVarHeaderParams = new java.util.HashMap<String, String>();
        java.util.Map<String, String> localVarCookieParams = new java.util.HashMap<String, String>();
        java.util.Map<String, Object> localVarFormParams = new java.util.HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "accessToken" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTranscriptionVocabularyValidateBeforeCall(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'createTranscriptionVocabularyRequest' is set
        if (createTranscriptionVocabularyRequest == null) {
            throw new ApiException("Missing the required parameter 'createTranscriptionVocabularyRequest' when calling createTranscriptionVocabulary(Async)");
        }
        

        okhttp3.Call localVarCall = createTranscriptionVocabularyCall(createTranscriptionVocabularyRequest, _callback);
        return localVarCall;

    }


    private ApiResponse<TranscriptionVocabularyResponse> createTranscriptionVocabularyWithHttpInfo(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest) throws ApiException {
        okhttp3.Call localVarCall = createTranscriptionVocabularyValidateBeforeCall(createTranscriptionVocabularyRequest, null);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createTranscriptionVocabularyAsync(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest, final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTranscriptionVocabularyValidateBeforeCall(createTranscriptionVocabularyRequest, _callback);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIcreateTranscriptionVocabularyRequest {
        private final CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest;

        private APIcreateTranscriptionVocabularyRequest(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest) {
            this.createTranscriptionVocabularyRequest = createTranscriptionVocabularyRequest;
        }

        /**
         * Build call for createTranscriptionVocabulary
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Transcription Vocabulary Created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return createTranscriptionVocabularyCall(createTranscriptionVocabularyRequest, _callback);
        }

        /**
         * Execute createTranscriptionVocabulary request
         * @return TranscriptionVocabularyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Transcription Vocabulary Created </td><td>  -  </td></tr>
         </table>
         */
        public TranscriptionVocabularyResponse execute() throws ApiException {
            ApiResponse<TranscriptionVocabularyResponse> localVarResp = createTranscriptionVocabularyWithHttpInfo(createTranscriptionVocabularyRequest);
            return localVarResp.getData();
        }

        /**
         * Execute createTranscriptionVocabulary request with HTTP info returned
         * @return ApiResponse&lt;TranscriptionVocabularyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Transcription Vocabulary Created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TranscriptionVocabularyResponse> executeWithHttpInfo() throws ApiException {
            return createTranscriptionVocabularyWithHttpInfo(createTranscriptionVocabularyRequest);
        }

        /**
         * Execute createTranscriptionVocabulary request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Transcription Vocabulary Created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {
            return createTranscriptionVocabularyAsync(createTranscriptionVocabularyRequest, _callback);
        }
    }

    /**
     * Create a Transcription Vocabulary
     * Create a new Transcription Vocabulary.
     * @param createTranscriptionVocabularyRequest  (required)
     * @return APIcreateTranscriptionVocabularyRequest
     * @http.response.details
     <table border="1">
        <caption>Response Summary</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Transcription Vocabulary Created </td><td>  -  </td></tr>
     </table>
     */
    public APIcreateTranscriptionVocabularyRequest createTranscriptionVocabulary(CreateTranscriptionVocabularyRequest createTranscriptionVocabularyRequest) {
        return new APIcreateTranscriptionVocabularyRequest(createTranscriptionVocabularyRequest);
    }
    private okhttp3.Call deleteTranscriptionVocabularyCall(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/video/v1/transcription-vocabularies/{TRANSCRIPTION_VOCABULARY_ID}"
            .replaceAll("\\{" + "TRANSCRIPTION_VOCABULARY_ID" + "\\}", localVarApiClient.escapeString(TRANSCRIPTION_VOCABULARY_ID.toString()));

        java.util.List<Pair> localVarQueryParams = new java.util.ArrayList<Pair>();
        java.util.List<Pair> localVarCollectionQueryParams = new java.util.ArrayList<Pair>();
        java.util.Map<String, String> localVarHeaderParams = new java.util.HashMap<String, String>();
        java.util.Map<String, String> localVarCookieParams = new java.util.HashMap<String, String>();
        java.util.Map<String, Object> localVarFormParams = new java.util.HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "accessToken" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteTranscriptionVocabularyValidateBeforeCall(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'TRANSCRIPTION_VOCABULARY_ID' is set
        if (TRANSCRIPTION_VOCABULARY_ID == null) {
            throw new ApiException("Missing the required parameter 'TRANSCRIPTION_VOCABULARY_ID' when calling deleteTranscriptionVocabulary(Async)");
        }
        

        okhttp3.Call localVarCall = deleteTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        return localVarCall;

    }


    private ApiResponse<Void> deleteTranscriptionVocabularyWithHttpInfo(String TRANSCRIPTION_VOCABULARY_ID) throws ApiException {
        okhttp3.Call localVarCall = deleteTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteTranscriptionVocabularyAsync(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class APIdeleteTranscriptionVocabularyRequest {
        private final String TRANSCRIPTION_VOCABULARY_ID;

        private APIdeleteTranscriptionVocabularyRequest(String TRANSCRIPTION_VOCABULARY_ID) {
            this.TRANSCRIPTION_VOCABULARY_ID = TRANSCRIPTION_VOCABULARY_ID;
        }

        /**
         * Build call for deleteTranscriptionVocabulary
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        }

        /**
         * Execute deleteTranscriptionVocabulary request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID);
        }

        /**
         * Execute deleteTranscriptionVocabulary request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID);
        }

        /**
         * Execute deleteTranscriptionVocabulary request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteTranscriptionVocabularyAsync(TRANSCRIPTION_VOCABULARY_ID, _callback);
        }
    }

    /**
     * Delete a Transcription Vocabulary
     * Deletes a Transcription Vocabulary. The Transcription Vocabulary&#39;s ID will be disassociated from any live streams using it. Transcription Vocabularies can be deleted while associated live streams are active. However, the words and phrases in the deleted Transcription Vocabulary will remain attached to those streams while they are active.
     * @param TRANSCRIPTION_VOCABULARY_ID The ID of the Transcription Vocabulary. (required)
     * @return APIdeleteTranscriptionVocabularyRequest
     * @http.response.details
     <table border="1">
        <caption>Response Summary</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public APIdeleteTranscriptionVocabularyRequest deleteTranscriptionVocabulary(String TRANSCRIPTION_VOCABULARY_ID) {
        return new APIdeleteTranscriptionVocabularyRequest(TRANSCRIPTION_VOCABULARY_ID);
    }
    private okhttp3.Call getTranscriptionVocabularyCall(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/video/v1/transcription-vocabularies/{TRANSCRIPTION_VOCABULARY_ID}"
            .replaceAll("\\{" + "TRANSCRIPTION_VOCABULARY_ID" + "\\}", localVarApiClient.escapeString(TRANSCRIPTION_VOCABULARY_ID.toString()));

        java.util.List<Pair> localVarQueryParams = new java.util.ArrayList<Pair>();
        java.util.List<Pair> localVarCollectionQueryParams = new java.util.ArrayList<Pair>();
        java.util.Map<String, String> localVarHeaderParams = new java.util.HashMap<String, String>();
        java.util.Map<String, String> localVarCookieParams = new java.util.HashMap<String, String>();
        java.util.Map<String, Object> localVarFormParams = new java.util.HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "accessToken" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTranscriptionVocabularyValidateBeforeCall(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'TRANSCRIPTION_VOCABULARY_ID' is set
        if (TRANSCRIPTION_VOCABULARY_ID == null) {
            throw new ApiException("Missing the required parameter 'TRANSCRIPTION_VOCABULARY_ID' when calling getTranscriptionVocabulary(Async)");
        }
        

        okhttp3.Call localVarCall = getTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        return localVarCall;

    }


    private ApiResponse<TranscriptionVocabularyResponse> getTranscriptionVocabularyWithHttpInfo(String TRANSCRIPTION_VOCABULARY_ID) throws ApiException {
        okhttp3.Call localVarCall = getTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, null);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTranscriptionVocabularyAsync(String TRANSCRIPTION_VOCABULARY_ID, final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetTranscriptionVocabularyRequest {
        private final String TRANSCRIPTION_VOCABULARY_ID;

        private APIgetTranscriptionVocabularyRequest(String TRANSCRIPTION_VOCABULARY_ID) {
            this.TRANSCRIPTION_VOCABULARY_ID = TRANSCRIPTION_VOCABULARY_ID;
        }

        /**
         * Build call for getTranscriptionVocabulary
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, _callback);
        }

        /**
         * Execute getTranscriptionVocabulary request
         * @return TranscriptionVocabularyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public TranscriptionVocabularyResponse execute() throws ApiException {
            ApiResponse<TranscriptionVocabularyResponse> localVarResp = getTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID);
            return localVarResp.getData();
        }

        /**
         * Execute getTranscriptionVocabulary request with HTTP info returned
         * @return ApiResponse&lt;TranscriptionVocabularyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TranscriptionVocabularyResponse> executeWithHttpInfo() throws ApiException {
            return getTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID);
        }

        /**
         * Execute getTranscriptionVocabulary request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {
            return getTranscriptionVocabularyAsync(TRANSCRIPTION_VOCABULARY_ID, _callback);
        }
    }

    /**
     * Retrieve a Transcription Vocabulary
     * Retrieves the details of a Transcription Vocabulary that has previously been created. Supply the unique Transcription Vocabulary ID and Mux will return the corresponding Transcription Vocabulary information. The same information is returned when creating a Transcription Vocabulary.
     * @param TRANSCRIPTION_VOCABULARY_ID The ID of the Transcription Vocabulary. (required)
     * @return APIgetTranscriptionVocabularyRequest
     * @http.response.details
     <table border="1">
        <caption>Response Summary</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIgetTranscriptionVocabularyRequest getTranscriptionVocabulary(String TRANSCRIPTION_VOCABULARY_ID) {
        return new APIgetTranscriptionVocabularyRequest(TRANSCRIPTION_VOCABULARY_ID);
    }
    private okhttp3.Call listTranscriptionVocabulariesCall(Integer limit, Integer page, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/video/v1/transcription-vocabularies";

        java.util.List<Pair> localVarQueryParams = new java.util.ArrayList<Pair>();
        java.util.List<Pair> localVarCollectionQueryParams = new java.util.ArrayList<Pair>();
        java.util.Map<String, String> localVarHeaderParams = new java.util.HashMap<String, String>();
        java.util.Map<String, String> localVarCookieParams = new java.util.HashMap<String, String>();
        java.util.Map<String, Object> localVarFormParams = new java.util.HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "accessToken" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTranscriptionVocabulariesValidateBeforeCall(Integer limit, Integer page, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = listTranscriptionVocabulariesCall(limit, page, _callback);
        return localVarCall;

    }


    private ApiResponse<ListTranscriptionVocabulariesResponse> listTranscriptionVocabulariesWithHttpInfo(Integer limit, Integer page) throws ApiException {
        okhttp3.Call localVarCall = listTranscriptionVocabulariesValidateBeforeCall(limit, page, null);
        Type localVarReturnType = new TypeToken<ListTranscriptionVocabulariesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTranscriptionVocabulariesAsync(Integer limit, Integer page, final ApiCallback<ListTranscriptionVocabulariesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listTranscriptionVocabulariesValidateBeforeCall(limit, page, _callback);
        Type localVarReturnType = new TypeToken<ListTranscriptionVocabulariesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIlistTranscriptionVocabulariesRequest {
        private Integer limit;
        private Integer page;

        private APIlistTranscriptionVocabulariesRequest() {
        }

        /**
         * Set limit
         * @param limit Number of items to include in the response (optional, default to 10)
         * @return APIlistTranscriptionVocabulariesRequest
         */
        public APIlistTranscriptionVocabulariesRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set page
         * @param page Offset by this many pages, of the size of &#x60;limit&#x60; (optional, default to 1)
         * @return APIlistTranscriptionVocabulariesRequest
         */
        public APIlistTranscriptionVocabulariesRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Build call for listTranscriptionVocabularies
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTranscriptionVocabulariesCall(limit, page, _callback);
        }

        /**
         * Execute listTranscriptionVocabularies request
         * @return ListTranscriptionVocabulariesResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ListTranscriptionVocabulariesResponse execute() throws ApiException {
            ApiResponse<ListTranscriptionVocabulariesResponse> localVarResp = listTranscriptionVocabulariesWithHttpInfo(limit, page);
            return localVarResp.getData();
        }

        /**
         * Execute listTranscriptionVocabularies request with HTTP info returned
         * @return ApiResponse&lt;ListTranscriptionVocabulariesResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListTranscriptionVocabulariesResponse> executeWithHttpInfo() throws ApiException {
            return listTranscriptionVocabulariesWithHttpInfo(limit, page);
        }

        /**
         * Execute listTranscriptionVocabularies request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListTranscriptionVocabulariesResponse> _callback) throws ApiException {
            return listTranscriptionVocabulariesAsync(limit, page, _callback);
        }
    }

    /**
     * List Transcription Vocabularies
     * List all Transcription Vocabularies.
     * @return APIlistTranscriptionVocabulariesRequest
     * @http.response.details
     <table border="1">
        <caption>Response Summary</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIlistTranscriptionVocabulariesRequest listTranscriptionVocabularies() {
        return new APIlistTranscriptionVocabulariesRequest();
    }
    private okhttp3.Call updateTranscriptionVocabularyCall(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = updateTranscriptionVocabularyRequest;

        // create path and map variables
        String localVarPath = "/video/v1/transcription-vocabularies/{TRANSCRIPTION_VOCABULARY_ID}"
            .replaceAll("\\{" + "TRANSCRIPTION_VOCABULARY_ID" + "\\}", localVarApiClient.escapeString(TRANSCRIPTION_VOCABULARY_ID.toString()));

        java.util.List<Pair> localVarQueryParams = new java.util.ArrayList<Pair>();
        java.util.List<Pair> localVarCollectionQueryParams = new java.util.ArrayList<Pair>();
        java.util.Map<String, String> localVarHeaderParams = new java.util.HashMap<String, String>();
        java.util.Map<String, String> localVarCookieParams = new java.util.HashMap<String, String>();
        java.util.Map<String, Object> localVarFormParams = new java.util.HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "accessToken" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateTranscriptionVocabularyValidateBeforeCall(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'TRANSCRIPTION_VOCABULARY_ID' is set
        if (TRANSCRIPTION_VOCABULARY_ID == null) {
            throw new ApiException("Missing the required parameter 'TRANSCRIPTION_VOCABULARY_ID' when calling updateTranscriptionVocabulary(Async)");
        }
        
        // verify the required parameter 'updateTranscriptionVocabularyRequest' is set
        if (updateTranscriptionVocabularyRequest == null) {
            throw new ApiException("Missing the required parameter 'updateTranscriptionVocabularyRequest' when calling updateTranscriptionVocabulary(Async)");
        }
        

        okhttp3.Call localVarCall = updateTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest, _callback);
        return localVarCall;

    }


    private ApiResponse<TranscriptionVocabularyResponse> updateTranscriptionVocabularyWithHttpInfo(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest) throws ApiException {
        okhttp3.Call localVarCall = updateTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest, null);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateTranscriptionVocabularyAsync(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest, final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateTranscriptionVocabularyValidateBeforeCall(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest, _callback);
        Type localVarReturnType = new TypeToken<TranscriptionVocabularyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIupdateTranscriptionVocabularyRequest {
        private final String TRANSCRIPTION_VOCABULARY_ID;
        private final UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest;

        private APIupdateTranscriptionVocabularyRequest(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest) {
            this.TRANSCRIPTION_VOCABULARY_ID = TRANSCRIPTION_VOCABULARY_ID;
            this.updateTranscriptionVocabularyRequest = updateTranscriptionVocabularyRequest;
        }

        /**
         * Build call for updateTranscriptionVocabulary
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return updateTranscriptionVocabularyCall(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest, _callback);
        }

        /**
         * Execute updateTranscriptionVocabulary request
         * @return TranscriptionVocabularyResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public TranscriptionVocabularyResponse execute() throws ApiException {
            ApiResponse<TranscriptionVocabularyResponse> localVarResp = updateTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest);
            return localVarResp.getData();
        }

        /**
         * Execute updateTranscriptionVocabulary request with HTTP info returned
         * @return ApiResponse&lt;TranscriptionVocabularyResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TranscriptionVocabularyResponse> executeWithHttpInfo() throws ApiException {
            return updateTranscriptionVocabularyWithHttpInfo(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest);
        }

        /**
         * Execute updateTranscriptionVocabulary request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table border="1">
            <caption>Response Summary</caption>
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TranscriptionVocabularyResponse> _callback) throws ApiException {
            return updateTranscriptionVocabularyAsync(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest, _callback);
        }
    }

    /**
     * Update a Transcription Vocabulary
     * Updates the details of a previously-created Transcription Vocabulary. Updates to Transcription Vocabularies are allowed while associated live streams are active. However, updates will not be applied to those streams while they are active.
     * @param TRANSCRIPTION_VOCABULARY_ID The ID of the Transcription Vocabulary. (required)
     * @param updateTranscriptionVocabularyRequest  (required)
     * @return APIupdateTranscriptionVocabularyRequest
     * @http.response.details
     <table border="1">
        <caption>Response Summary</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public APIupdateTranscriptionVocabularyRequest updateTranscriptionVocabulary(String TRANSCRIPTION_VOCABULARY_ID, UpdateTranscriptionVocabularyRequest updateTranscriptionVocabularyRequest) {
        return new APIupdateTranscriptionVocabularyRequest(TRANSCRIPTION_VOCABULARY_ID, updateTranscriptionVocabularyRequest);
    }
}
